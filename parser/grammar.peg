{
package parser

import (
	"bytes"
	"strconv"
	"strings"

	"github.com/ragpanda/model-ql/util"
)
    

}



Grammar ← __ statements:( Statement __ )* (EOF / SyntaxError) {
	return parseCompile(statements)
}


Statement ← ModelDefine 

ModelDefine ←  "model" _ ident:Identifier _ "{" __ selectData:Select __ "}" {
	return parseModel(ident, selectData)
}


Select ← "select" __ fieldList:SelectFieldList __ "from" __ model:Model __ join:JoinClause? __ where:WhereClause? __{
	return parseSelectStmt(fieldList, model, join, where)
}

SelectFieldList ← SelectField  __ ( "," __ SelectField __)*
Model ← Identifier 
SelectField ← name:(SelectFieldIdentifier)  __ alias:("as" __  Identifier)?  {
	return parseSelectField(name, alias)
}

SelectFieldIdentifier ←  "*" / Identifier 





JoinClause ← __ Join+ 
Join ←   "join" __ target:JoinTarget __ "on"  __ self:MiltiLevelField __ compare:CompareOp __ ref:MiltiLevelField __ {
	return parseJoin(target, self, compare, ref)
}

JoinTarget ← name:(Identifier)  __ alias:("as" __ Identifier)? {
	return parseJoinTarget(name, alias)
}


WhereClause ←  "where" __ WhereList 
WhereList ← first:Where __ tails:WhereTail* {
	return parseWhereList(first, tails)
}
WhereTail  ← b:BoolOP __ w:Where __ {
	return []interface{}{BoolOp(parseString(b)), w}, nil
}

Where ← WhereCondition / WhereHasBracket
WhereHasBracket ←  "(" __ WhereList  __ ")" 
WhereCondition ← field:MiltiLevelField __ op:CompareOp __  condition:Condition {
	return parseWhereCondition(field, op, condition)
}


Condition ← Number / Bool/ String/ Null / Ref

MiltiLevelField  ←  ident:(Identifier  ("." Identifier)*){
	return parseMiltiLevelField(ident)
}

BoolOP ←  "and"/ "or"/ "not" {
	return BoolOp(string(c.text)), nil
}
CompareOp  ←  "!="/ "="/ "not in"/ "in" {
	return CompareOp(string(c.text)), nil
}





// Value define
Number ← '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    // JSON numbers have the same syntax as Go's, and are parseable using
    // strconv.
    r, err := strconv.ParseFloat(string(c.text), 64)
	return Number(r), err
}

Integer ← '0' / NonZeroDecimalDigit DecimalDigit*

Exponent ← 'e'i [+-]? DecimalDigit+

String ← '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
    r, err := strconv.Unquote(string(c.text))
	return StringObj(r), err
}

EscapedChar ← [\x00-\x1f"\\]

EscapeSequence ← SingleCharEscape / UnicodeEscape

SingleCharEscape ← ["\\/bfnrt]

UnicodeEscape ← 'u' HexDigit HexDigit HexDigit HexDigit

DecimalDigit ← [0-9]

NonZeroDecimalDigit ← [1-9]

HexDigit ← [0-9a-f]i

Bool ← "true" { return Boolean(true), nil } / "false" { return Boolean(false), nil }

Null ← "null" { return None(0), nil } 

Ref ←  "$" name:Identifier {
	return Ref(parseString(name)), nil
}



// Basic Grammar
Keyword ←  BoolOP /CompareOp
Identifier ← !Keyword (Letter / '_')+ (Letter / Digit / [_])* {
	return Identifier(string(c.text)), nil
}
ListSeparator ← [,;]
Letter ← [A-Za-z]
Digit ← [0-9]


SourceChar ← .
Comment ← MultiLineComment / SingleLineComment
MultiLineComment ← "/*" ( !"*/" SourceChar )* "*/"
MultiLineCommentNoLineTerminator ← "/*" ( !( "*/" / EOL ) SourceChar )* "*/"
SingleLineComment ← ("//" ( !EOL SourceChar )*) / ("#" ( !EOL SourceChar )*)


__ ← ( Whitespace / EOL / Comment )*
NoCommentIgnore ← ( Whitespace / EOL )*
_ ← (Whitespace)*
WS ← Whitespace*

Whitespace ← [ \t\r]
EOL ← '\n'
EOS ← __ ';' / _ SingleLineComment? EOL / __ EOF

EOF ← !.


SyntaxError ← . {
	return nil, errors.New("parser: syntax error")
}
